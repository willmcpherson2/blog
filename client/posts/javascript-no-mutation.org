* JavaScript: No Mutation

JavaScript has a problem: objects. On the surface, objects are really handy:

1. Objects can be used as simple key-value stores, arrays, algebraic data types or OOP objects
2. Objects have a plethora of ergonomic features:
   - Dot notation ~foo.x~
   - Bracket notation ~foo["x"]~
   - Indexing ~foo[0]~
   - Spread syntax ~{ ...foo, x: 1 }~
   - Computed property names ~{ ...foo, [compute()]: 1 }~
   - Methods ~{ x() { return 1; } }~
3. Objects work incredibly well with TypeScript

/The dark side/:

1. Objects are mutable
2. Objects are references

For example:

   #+begin_src js
     const f = foo => {
       foo.x += 1;
       return foo;
     }

     const foo = { x: 1 };

     // OK, we declared it like that
     console.log(foo); // { x: 1 }

     // OK, this is intended by the function
     console.log(f(foo)); // { x: 2 }

     // !?
     console.log(foo); // { x: 2 }
     // Our function is doing secret operations
     // We have a result and an effect. We are not "doing one thing well"
     // We lost our old information
     // Things get harder to track as we add control flow and call more functions
   #+end_src

If you remove mutability, you get "pass by read-only reference". ~foo === f(foo)~ would still be ~true~ because of referential equality. In the example above, ~foo.x += 1~ would not be valid and you would need to use ~return { x: foo.x + 1 }~.

If you remove references, you get "pass by mutable value". ~foo === f(foo)~ would now be ~false~ because objects would be copied. In the example above, passing the object ~foo~ would behave in the same way as passing the number ~x~ directly.

[fn:named] There are a few ways to copy JavaScript objects:

1. Perform shallow clones via spread syntax ~{ ...data }~ and hope that you've prevented undesirable mutations
2. ~JSON.parse(JSON.stringify(data))~, which is slow and relies on serialisation which prevents copying functions
3. ~structuredClone(data)~, which is faster but also only works for serialisable objects

Obviously, JavaScript was just never built to support copying. Even if there was some easy way to copy objects, it's still up to the programmer to ensure that copies and mutations happen in the right places.

** Solutions

*** Don't mutate

Surprisingly, it's not too difficult to just never use mutation in JavaScript. While that may sound totally unnatural, it works like any other immutable language.

We avoid /the dark side/ by removing mutation. Objects are still references, but this no longer really matters. Consequently, shallow copies work now. For example:

#+begin_src js
  const foo1 = { x: 1, bar: { y: 1 } };    // { x: 1, bar: { y: 1 } }
  const foo2 = { ...foo1, x: foo1.x + 1 }; // { x: 2, bar: { y: 1 } }
#+end_src

Because we'll never mutate an object, we will never observe the depth of a clone. That is unless you use ~===~, which is a topic for another day.

*** fp-ts

[[https://github.com/gcanti/fp-ts][fp-ts]] is a library for typed functional programming. If you're going to write immutable JavaScript, you can't rely on builtin methods. For example, [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array][the Array API]] provides a mix of pure and mutating methods. Fortunately [[https://gcanti.github.io/fp-ts/modules/Array.ts.html][the fp-ts Array module]] is totally pure and provides way more functionality.

*** ts-pattern

[[https://github.com/gvergnaud/ts-pattern][ts-pattern]] is an exhaustive pattern matching library. Pattern matching is the key to writing pure functions and ts-pattern even rivals languages with built-in pattern matching.

*** monocle-ts

[[https://github.com/gcanti/monocle-ts][monocle-ts]] is a functional optics library. You might not actually need this. I thought it was the key to writing good JavaScript because it provides a solution to nested updates, but I eventually realised that immutable programming unlocks shallow copies.

*** TypeScript

TypeScript adds a structural type system to JavaScript and makes it significantly safer and more ergonomic.
